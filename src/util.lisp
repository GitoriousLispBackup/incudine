;;; Copyright (c) 2013 Tito Latini
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

(in-package :incudine)

(defun init ()
  (dolist (fn *initialize-hook*)
    (funcall fn)))

;;; FUNCTIONS are generated by the function defined with DEFSYNTH.
;;; The last function is an arbitrary function without arguments;
;;; it is useful to define recursive sequences.
(defmacro synth-seq (&rest functions)
  (with-gensyms (n)
    (labels ((%synth-seq (functions)
               (if (null functions)
                   nil
                   (if (cdr functions)
                       (append (car functions)
                               (list :stop-hook
                                     `(list (lambda (,n)
                                              (declare (ignore ,n))
                                              ,(%synth-seq (cdr functions))))))
                       (car functions)))))
      (%synth-seq functions))))

(defgeneric free (obj))

(in-package :incudine.util)

;;; TYPES

;; NON-NEGATIVE-FIXNUM64 used to get a better optimization
;; on 64bit machines. MOST-POSITIVE-FIXNUM 2^59-1 is good
;; at least with SBCL and CCL.
(define-constant most-positive-fixnum64 (1- (ash 1 59)))

(deftype non-negative-fixnum64 () '(integer 0 #.(1- (ash 1 59))))

;; FLOAT with arbitrary range between -2^63 and 2^63.
;; Used in SBCL on X86 with SIN, COS and TAN.
(deftype limited-sample () (let ((high (coerce 4.0e18 'sample)))
                             `(,*sample-type* ,(- high) ,high)))

(deftype maybe-limited-sample () #+(and sbcl x86) 'limited-sample
                                 #-(and sbcl x86) 'sample)

(deftype channel-number () '(integer 0 #.*max-number-of-channels*))

(deftype bus-number () '(integer 0 20000))

;;; MISC

(defvar *dummy-function-without-args* (lambda ()))
(declaim (type function *dummy-function-without-args*))

(declaim (inline sample))
(defun sample (number)
  (coerce number 'sample))

(defmacro foreach-channel ((var channels &optional (result nil))
                           &body body)
  `(do ((,var 0 (1+ ,var)))
       ((>= ,var ,channels) ,result)
     (declare (type channel-number ,var))
     ,@body))

(declaim (inline lin->db))
(defun lin->db (x)
  (let ((in (if (zerop x) least-positive-sample x)))
    (* (coerce 20.0 'sample)
       (log in (coerce 10.0 'sample)))))

(declaim (inline db->lin))
(defun db->lin (x)
  (expt (coerce 10.0 'sample) (* x (coerce 0.05 'sample))))

(declaim (inline linear-interp))
(defun linear-interp (in y0 y1)
  (declare (type sample in y0 y1))
  (+ y0 (* in (- y1 y0))))

(declaim (inline cos-interp))
(defun cos-interp (in y0 y1)
  (declare (type sample in y0 y1))
  (linear-interp (* (- 1 (cos (the limited-sample
                                (* in (coerce pi 'sample)))))
                    0.5) y0 y1))

;;; Catmull-Rom spline
(declaim (inline cubic-interp))
(defun cubic-interp (in y0 y1 y2 y3)
  (declare (type sample in y0 y1 y2 y3))
  (let ((a0 (+ (* -0.5 y0) (* 1.5 y1) (* -1.5 y2) (* 0.5 y3)))
        (a1 (+ y0 (* -2.5 y1) (* 2.0 y2) (* -0.5 y3)))
        (a2 (+ (* -0.5 y0) (* 0.5 y2))))
    (+ (* in (+ (* in (+ (* a0 in) a1)) a2)) y1)))

(declaim (inline set-sample-rate))
(defun set-sample-rate (value)
  (setf *sample-rate* (coerce value 'sample)
        *sample-duration* (/ 1.0 *sample-rate*))
  (mapc #'funcall sample-rate-hook)
  (mapc #'funcall sample-duration-hook)
  *sample-rate*)

(declaim (inline set-sample-duration))
(defun set-sample-duration (value)
  (setf *sample-duration* (coerce value 'sample)
        *sample-rate* (/ 1.0 *sample-duration*))
  (mapc #'funcall sample-rate-hook)
  (mapc #'funcall sample-duration-hook)
  *sample-duration*)

(declaim (inline set-sound-velocity))
(defun set-sound-velocity (value)
  (setf *sound-velocity*   (coerce value 'sample)
        *r-sound-velocity* (/ 1.0 *sound-velocity*))
  (mapc #'funcall sound-velocity-hook)
  *sound-velocity*)

(declaim (inline sample->fixnum))
(defun sample->fixnum (x)
  (declare (type (sample
                  #.(coerce (ash most-negative-fixnum -1) 'sample)
                  #.(coerce (ash most-positive-fixnum -1) 'sample)) x))
  (multiple-value-bind (result rem) (floor x)
    (declare (ignore rem))
    result))

(declaim (inline sample->int))
(defun sample->int (x)
  (declare (type sample x))
  (multiple-value-bind (result rem) (floor x)
    (declare (ignore rem))
    result))

(declaim (inline calc-lobits))
(defun calc-lobits (size)
  (declare (type non-negative-fixnum size))
  (if (>= size +table-maxlen+)
      0
      (do ((i size (ash i 1))
           (lobits 0 (1+ lobits)))
          ((plusp (logand i +table-maxlen+)) lobits)
        (declare (type non-negative-fixnum i lobits)))))

(declaim (inline rt-thread-p))
(defun rt-thread-p ()
  (eq (bt:current-thread) *rt-thread*))

(defmacro with-foreign-rt-object ((var type &optional (count 1)) &body body)
  `(let ((,var (foreign-rt-alloc ,type :count ,count)))
     (unwind-protect (progn ,@body)
       (foreign-rt-free ,var))))

(defmacro %with-foreign-object ((var type &optional (count 1)) &body body)
  `(if (rt-thread-p)
       (with-foreign-rt-object (,var ,type ,count) ,@body)
       (with-foreign-object (,var ,type ,count) ,@body)))

(defmacro data-ref (data index)
  `(mem-ref ,data 'sample (the non-negative-fixnum
                            (* ,index +foreign-sample-size+))))

;;; The expansion inside a definition of a VUG is different
;;; (see %WITH-SAMPLES in `vug/vug.lisp')
(defmacro with-samples (bindings &body body)
  (with-gensyms (c-array)
    (let ((size (length bindings))
          (count 0))
      (if *use-foreign-sample-p*
          `(%with-foreign-object (,c-array 'sample ,size)
             (symbol-macrolet
                 ,(mapcar
                   (lambda (x)
                     (prog1 `(,(if (consp x) (car x) x)
                               (mem-aref ,c-array 'sample ,count))
                       (incf count)))
                   bindings)
               (psetf ,@(loop for i in bindings
                              when (consp i)
                              append `(,(car i) (coerce ,(cadr i) 'sample))))
               ,@body))
          `(let (,@(mapcar (lambda (x)
                             (if (consp x)
                                 `(,(car x) (coerce ,(cadr x) 'sample))
                                 `(,x ,+sample-zero+)))
                           bindings))
             (declare (type sample ,@(mapcar (lambda (x)
                                               (if (consp x) (car x) x))
                                             bindings)))
             ,@body)))))

(defmacro with-samples* (bindings &body body)
  (with-gensyms (c-array)
    (let ((size (length bindings))
          (count 0))
      (if *use-foreign-sample-p*
          `(%with-foreign-object (,c-array 'sample ,size)
             (symbol-macrolet
                 ,(mapcar
                   (lambda (x)
                     (prog1 `(,(if (consp x) (car x) x)
                               (mem-aref ,c-array 'sample ,count))
                       (incf count)))
                   bindings)
               (setf ,@(loop for i in bindings
                             when (consp i)
                             append `(,(car i) (coerce ,(cadr i) 'sample))))
               ,@body))
          `(let* (,@(mapcar (lambda (x)
                              (if (consp x)
                                  `(,(car x) (coerce ,(cadr x) 'sample))
                                  `(,x ,+sample-zero+)))
                            bindings))
             (declare (type sample ,@(mapcar (lambda (x)
                                               (if (consp x) (car x) x))
                                             bindings)))
             ,@body)))))

(defmacro with-complex (real-and-imag-vars pointer &body body)
  `(symbol-macrolet ((,(car real-and-imag-vars)
                      (mem-ref ,pointer 'sample))
                     (,(cadr real-and-imag-vars)
                      (mem-ref ,pointer 'sample +foreign-sample-size+)))
     ,@body))

(defmacro do-complex ((realpart-var imagpart-var pointer size) &body body)
  (with-gensyms (i addr)
    `(do ((,i 0 (1+ ,i))
          (,addr (pointer-address ,pointer)
                 (pointer-address
                  (inc-pointer (make-pointer ,addr)
                               +foreign-complex-size+))))
         ((>= ,i ,size))
       (declare (type unsigned-byte ,i))
       (symbol-macrolet ((,realpart-var (foreign-slot-value (make-pointer ,addr)
                                          '(:struct sample-complex) 'realpart))
                         (,imagpart-var (foreign-slot-value (make-pointer ,addr)
                                          '(:struct sample-complex) 'imagpart)))
         ,@body))))

(define-constant +double-float-bias+ 1022)
(define-constant +double-float-digits+ 53)

(declaim (inline double-float-exponent))
(defun double-float-exponent (x)
  (declare (type double-float x)
           #+(or cmu sbcl) (values fixnum))
  (- (ldb '(11 . 20) (double-float-high-bits x))
     +double-float-bias+
     +double-float-digits+))

;;; Spinlock

(defstruct (spinlock (:constructor make-spinlock (&optional name))
                     (:copier nil))
  (name "Anonymous spinlock" :type string)
  (state 0 :type fixnum))

(defmethod print-object ((obj spinlock) stream)
  (format stream "#<~A ~S>" (type-of obj) (spinlock-name obj)))

(declaim (inline acquire-spinlock))
(defun acquire-spinlock (spinlock)
  (declare (type spinlock spinlock))
  (loop while (= 1 (compare-and-swap (spinlock-state spinlock) 0 1)))
  t)

(declaim (inline release-spinlock))
(defun release-spinlock (spinlock)
  (declare (type spinlock spinlock))
  (barrier (:memory))
  (setf (spinlock-state spinlock) 0)
  nil)

;;; Acquire spinlock for the dynamic scope of BODY.
;;; Inspired by SB-THREAD:WITH-MUTEX
(defmacro with-spinlock-held ((place) &body body)
  (with-gensyms (got-it)
    `(let ((,got-it nil))
       (declare (sb-int:truly-dynamic-extent ,got-it))
       (without-interrupts
         (unwind-protect
              (when (setq ,got-it
                          (sb-sys:allow-with-interrupts
                            (acquire-spinlock ,place)))
                (sb-sys:with-local-interrupts
                  ,@body))
           (when ,got-it
             (release-spinlock ,place)))))))
