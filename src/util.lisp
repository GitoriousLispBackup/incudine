;;; Copyright (c) 2013 Tito Latini
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

(in-package :incudine)

(defun init ()
  (dolist (fn *initialize-hook*)
    (funcall fn)))

;;; FUNCTIONS are generated by the function defined with DSP!.
;;; The last function is an arbitrary function without arguments;
;;; it is useful to define recursive sequences.
(defmacro dsp-seq (&rest functions)
  (with-gensyms (n)
    (labels ((%dsp-seq (functions)
               (if (null functions)
                   nil
                   (if (cdr functions)
                       (append (car functions)
                               (list :stop-hook
                                     `(list (lambda (,n)
                                              (declare (ignore ,n))
                                              ,(%dsp-seq (cdr functions))))))
                       (car functions)))))
      (%dsp-seq functions))))

(defgeneric free (obj))

(defgeneric free-p (obj))

(defgeneric scale (obj mult))

(defgeneric normalize (obj norm-value))

(defgeneric rescale (obj min max))

(defgeneric data (obj))

(defgeneric (setf data) (values obj))

(defgeneric touch (obj))

(in-package :incudine.util)

;;; TYPES

;; NON-NEGATIVE-FIXNUM64 used to get a better optimization
;; on 64bit machines. MOST-POSITIVE-FIXNUM 2^59-1 is good
;; at least with SBCL and CCL.
(define-constant most-positive-fixnum64 (1- (ash 1 59)))

(deftype non-negative-fixnum64 () '(integer 0 #.(1- (ash 1 59))))

;; FLOAT with arbitrary range between -2^63 and 2^63.
;; Used in SBCL on X86 with SIN, COS and TAN.
(deftype limited-sample () (let ((high (coerce 4.0e18 'sample)))
                             `(,*sample-type* ,(- high) ,high)))

(deftype maybe-limited-sample () #+(and sbcl x86) 'limited-sample
                                 #-(and sbcl x86) 'sample)

(deftype channel-number () '(integer 0 #.*max-number-of-channels*))

(deftype bus-number () '(integer 0 20000))

;;; MISC

(defvar *dummy-function-without-args* (lambda ()))
(declaim (type function *dummy-function-without-args*))

(defmacro with-ensure-symbol (names &body forms)
  `(let ,(mapcar (lambda (name)
                   `(,name (ensure-symbol ,(symbol-name name))))
                 names)
     ,@forms))

(declaim (inline sample))
(defun sample (number)
  (coerce number 'sample))

(defun apply-sample-coerce (form)
  (if (atom form)
      (cond ((and (numberp form) (floatp form))
             (sample form))
            ((eq form 'pi) '(sample pi))
            (t form))
      (cons (apply-sample-coerce (car form))
            (apply-sample-coerce (cdr form)))))

(defun alloc-multi-channel-data (channels size)
  (declare (type channel-number channels)
           (type positive-fixnum size))
  (let ((ptr (cffi:foreign-alloc :pointer :count channels)))
    (dotimes (ch channels ptr)
      (declare (type channel-number ch))
      (setf (cffi:mem-aref ptr :pointer ch)
            (foreign-alloc-sample size)))))

(defun free-multi-channel-data (data channels)
  (dotimes (ch channels)
    (let ((frame (cffi:mem-aref data :pointer ch)))
      (unless (cffi:null-pointer-p frame)
        (foreign-free frame))))
  (foreign-free data)
  (values))

(defmacro dochannels ((var channels &optional (result nil))
                      &body body)
  `(do ((,var 0 (1+ ,var)))
       ((>= ,var ,channels) ,result)
     (declare (type channel-number ,var))
     ,@body))

(declaim (inline lin->db))
(defun lin->db (x)
  (let ((in (if (zerop x) least-positive-sample x)))
    (* (sample 20) (log in (sample 10)))))

(declaim (inline db->lin))
(defun db->lin (x)
  (expt (sample 10) (* x (sample 0.05))))

(declaim (inline linear-interp))
(defun linear-interp (in y0 y1)
  (declare (type sample in y0 y1))
  (+ y0 (* in (- y1 y0))))

(declaim (inline cos-interp))
(defun cos-interp (in y0 y1)
  (declare (type sample in y0 y1))
  (linear-interp (* (- 1 (cos (the limited-sample
                                (* in (sample pi)))))
                    0.5) y0 y1))

;;; Catmull-Rom spline
(declaim (inline cubic-interp))
(defun cubic-interp (in y0 y1 y2 y3)
  (declare (type sample in y0 y1 y2 y3))
  (let ((a0 (+ (* -0.5 y0) (* 1.5 y1) (* -1.5 y2) (* 0.5 y3)))
        (a1 (+ y0 (* -2.5 y1) (* 2.0 y2) (* -0.5 y3)))
        (a2 (+ (* -0.5 y0) (* 0.5 y2))))
    (+ (* in (+ (* in (+ (* a0 in) a1)) a2)) y1)))

(declaim (inline t60->pole))
(defun t60->pole (time)
  "Return a real pole for a 60dB exponential decay in TIME seconds."
  (if (plusp time)
      ;; tau = time / log(0.001) = time / 6.9077
      (exp (/ (* +log001+ *sample-duration*) time))
      +sample-zero+))

(declaim (inline set-sample-rate))
(defun set-sample-rate (value)
  (setf *sample-rate* (sample value)
        *sample-duration* (/ 1.0 *sample-rate*))
  (mapc #'funcall sample-rate-hook)
  (mapc #'funcall sample-duration-hook)
  *sample-rate*)

(declaim (inline set-sample-duration))
(defun set-sample-duration (value)
  (setf *sample-duration* (sample value)
        *sample-rate* (/ 1.0 *sample-duration*))
  (mapc #'funcall sample-rate-hook)
  (mapc #'funcall sample-duration-hook)
  *sample-duration*)

(declaim (inline set-sound-velocity))
(defun set-sound-velocity (value)
  (setf *sound-velocity*   (sample value)
        *r-sound-velocity* (/ 1.0 *sound-velocity*))
  (mapc #'funcall sound-velocity-hook)
  *sound-velocity*)

(declaim (inline sample->fixnum))
(defun sample->fixnum (x)
  (declare (type (sample
                  #.(coerce (ash most-negative-fixnum -1) 'sample)
                  #.(coerce (ash most-positive-fixnum -1) 'sample)) x))
  (multiple-value-bind (result rem) (floor x)
    (declare (ignore rem))
    result))

(declaim (inline sample->int))
(defun sample->int (x)
  (declare (type sample x))
  (multiple-value-bind (result rem) (floor x)
    (declare (ignore rem))
    result))

(declaim (inline calc-lobits))
(defun calc-lobits (size)
  (declare (type non-negative-fixnum size))
  (if (>= size +table-maxlen+)
      0
      (do ((i size (ash i 1))
           (lobits 0 (1+ lobits)))
          ((plusp (logand i +table-maxlen+)) lobits)
        (declare (type non-negative-fixnum i lobits)))))

(declaim (inline rt-thread-p))
(defun rt-thread-p ()
  (eq (bt:current-thread) *rt-thread*))

(defmacro with-foreign-rt-object ((var type &optional (count 1)) &body body)
  `(let ((,var (foreign-rt-alloc ,type :count ,count)))
     (unwind-protect (progn ,@body)
       (foreign-rt-free ,var))))

(defmacro %with-foreign-object ((var type &optional (count 1)) &body body)
  `(if (rt-thread-p)
       (with-foreign-rt-object (,var ,type ,count) ,@body)
       (with-foreign-object (,var ,type ,count) ,@body)))

(declaim (inline smp-ref))
(defun smp-ref (samples index)
  (mem-ref samples 'sample (the non-negative-fixnum
                             (* index +foreign-sample-size+))))

(declaim (inline set-smp-ref))
(defun set-smp-ref (samples index value)
  (setf (mem-ref samples 'sample (the non-negative-fixnum
                                   (* index +foreign-sample-size+)))
        (sample value)))

(defsetf smp-ref set-smp-ref)

;;; The expansion inside a definition of a VUG is different
;;; (see %WITH-SAMPLES in `vug/vug.lisp')
(defmacro with-samples (bindings &body body)
  (with-gensyms (c-array)
    (let ((size (length bindings))
          (count 0))
      (if *use-foreign-sample-p*
          `(%with-foreign-object (,c-array 'sample ,size)
             (symbol-macrolet
                 ,(mapcar
                   (lambda (x)
                     (prog1 `(,(if (consp x) (car x) x)
                               (smp-ref ,c-array ,count))
                       (incf count)))
                   bindings)
               (psetf ,@(loop for i in bindings
                              when (consp i)
                              append `(,(car i) (sample ,(cadr i)))))
               ,@body))
          `(let (,@(mapcar (lambda (x)
                             (if (consp x)
                                 `(,(car x) (sample ,(cadr x)))
                                 `(,x ,+sample-zero+)))
                           bindings))
             (declare (type sample ,@(mapcar (lambda (x)
                                               (if (consp x) (car x) x))
                                             bindings)))
             ,@body)))))

(defmacro with-samples* (bindings &body body)
  (with-gensyms (c-array)
    (let ((size (length bindings))
          (count 0))
      (if *use-foreign-sample-p*
          `(%with-foreign-object (,c-array 'sample ,size)
             (symbol-macrolet
                 ,(mapcar
                   (lambda (x)
                     (prog1 `(,(if (consp x) (car x) x)
                               (smp-ref ,c-array ,count))
                       (incf count)))
                   bindings)
               (setf ,@(loop for i in bindings
                             when (consp i)
                             append `(,(car i) (sample ,(cadr i)))))
               ,@body))
          `(let* (,@(mapcar (lambda (x)
                              (if (consp x)
                                  `(,(car x) (sample ,(cadr x)))
                                  `(,x ,+sample-zero+)))
                            bindings))
             (declare (type sample ,@(mapcar (lambda (x)
                                               (if (consp x) (car x) x))
                                             bindings)))
             ,@body)))))

(defmacro with-complex (real-and-imag-vars pointer &body body)
  `(symbol-macrolet ((,(car real-and-imag-vars)
                      (smp-ref ,pointer 0))
                     (,(cadr real-and-imag-vars)
                      (smp-ref ,pointer 1)))
     ,@body))

(defmacro do-complex ((realpart-var imagpart-var pointer size) &body body)
  (with-gensyms (i addr)
    `(do ((,i 0 (1+ ,i))
          (,addr (pointer-address ,pointer)
                 (pointer-address
                  (inc-pointer (make-pointer ,addr)
                               +foreign-complex-size+))))
         ((>= ,i ,size))
       (declare (type unsigned-byte ,i))
       (symbol-macrolet ((,realpart-var (foreign-slot-value (make-pointer ,addr)
                                          '(:struct sample-complex) 'realpart))
                         (,imagpart-var (foreign-slot-value (make-pointer ,addr)
                                          '(:struct sample-complex) 'imagpart)))
         ,@body))))

;;; Spinlock

(defstruct (spinlock (:constructor make-spinlock (&optional name))
                     (:copier nil))
  (name "Anonymous spinlock" :type string)
  (state 0 :type fixnum))

(defmethod print-object ((obj spinlock) stream)
  (format stream "#<~A ~S>" (type-of obj) (spinlock-name obj)))

(declaim (inline acquire-spinlock))
(defun acquire-spinlock (spinlock)
  (declare (type spinlock spinlock))
  (loop while (= 1 (compare-and-swap (spinlock-state spinlock) 0 1)))
  t)

(declaim (inline release-spinlock))
(defun release-spinlock (spinlock)
  (declare (type spinlock spinlock))
  (barrier (:memory))
  (setf (spinlock-state spinlock) 0)
  nil)

;;; Acquire spinlock for the dynamic scope of BODY.
;;; Inspired by SB-THREAD:WITH-MUTEX
#+sbcl
(defmacro with-spinlock-held ((place) &body body)
  (with-gensyms (got-it)
    `(let ((,got-it nil))
       (declare (sb-int:truly-dynamic-extent ,got-it))
       (without-interrupts
         (unwind-protect
              (when (setq ,got-it
                          (sb-sys:allow-with-interrupts
                            (acquire-spinlock ,place)))
                (sb-sys:with-local-interrupts
                  ,@body))
           (when ,got-it
             (release-spinlock ,place)))))))

#-sbcl
(defmacro with-spinlock-held ((place) &body body)
  `(unwind-protect
        (progn
          (acquire-spinlock ,place)
          ,@body)
     (release-spinlock ,place)))
